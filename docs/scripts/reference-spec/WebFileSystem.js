const ReferenceSpecRecord = {
  "packages": {
    "es-search-references": {
      "guest": "/*\ndeclare function searchReferences(\n  this: void,\n  resultsKey: string,\n  targetValue: WeakKey,\n  heldValues: readonly WeakKey[],\n  strongReferencesOnly: boolean,\n): void;\n*/\nexport {};\\n"
    }
  },
  "urls": {
    "virtual": {
      "home": {
        "fixtures": {
          "OneToOneStrongMap": {
            "OneToOneStrongMap.js": "import WeakStrongMap from \"./WeakStrongMap.js\";\nclass InternalKey {\n    doNotCallMe() {\n        throw new Error(\"don't call me\");\n    }\n}\nObject.freeze(InternalKey);\nObject.freeze(InternalKey.prototype);\nexport default class OneToOneStrongMap {\n    #baseMap = new WeakStrongMap;\n    #weakValueToInternalKeyMap = new WeakMap;\n    /**\n     * Bind two sets of keys and values together.\n     *\n     * @param strongKey_1 - The strongly held key.\n     * @param value_1 - The first value.\n     * @param strongKey_2 - The second key.\n     * @param value_2 - The second value.\n     */\n    bindOneToOne(strongKey_1, value_1, strongKey_2, value_2) {\n        let internalKey = this.#weakValueToInternalKeyMap.get(value_1);\n        const __otherInternalKey__ = this.#weakValueToInternalKeyMap.get(value_2);\n        if (!internalKey) {\n            internalKey = __otherInternalKey__ || new InternalKey;\n        }\n        else if (__otherInternalKey__ && (__otherInternalKey__ !== internalKey)) {\n            return this.#attemptMergeKeys(internalKey, __otherInternalKey__);\n        }\n        const __hasKeySet1__ = this.#baseMap.has(internalKey, strongKey_1);\n        const __hasKeySet2__ = this.#baseMap.has(internalKey, strongKey_2);\n        if (__hasKeySet1__ && (this.#baseMap.get(internalKey, strongKey_1) !== value_1))\n            throw new Error(\"value_1 mismatch!\");\n        if (__hasKeySet2__ && (this.#baseMap.get(internalKey, strongKey_2) !== value_2))\n            throw new Error(\"value_2 mismatch!\");\n        this.#weakValueToInternalKeyMap.set(value_1, internalKey);\n        this.#weakValueToInternalKeyMap.set(value_2, internalKey);\n        if (!__hasKeySet1__)\n            this.#baseMap.set(internalKey, strongKey_1, value_1);\n        if (!__hasKeySet2__)\n            this.#baseMap.set(internalKey, strongKey_2, value_2);\n    }\n    #attemptMergeKeys(firstInternalKey, secondInternalKey) {\n        const firstKeySet = this.#baseMap.strongKeysFor(firstInternalKey);\n        const secondKeySet = this.#baseMap.strongKeysFor(secondInternalKey);\n        const unionKeySet = new Set([\n            ...firstKeySet, ...secondKeySet\n        ]);\n        if (unionKeySet.size < firstKeySet.size + secondKeySet.size)\n            throw new Error(\"value_1 and value_2 have conflicting keys!\");\n        for (const strongKey of secondKeySet) {\n            const value = this.#baseMap.get(secondInternalKey, strongKey);\n            this.#baseMap.set(firstInternalKey, strongKey, value);\n            this.#baseMap.delete(secondInternalKey, strongKey);\n            this.#weakValueToInternalKeyMap.set(value, firstInternalKey);\n        }\n    }\n    /** Clear all bindings. */\n    clear() {\n        this.#baseMap = new WeakStrongMap;\n        this.#weakValueToInternalKeyMap = new WeakMap;\n    }\n    /**\n     * Delete a target value.\n     *\n     * @param value -The value.\n     * @param strongKey - The strongly held key.\n     * @returns True if the target value was deleted.\n     */\n    delete(value, strongKey) {\n        const weakKey = this.#weakValueToInternalKeyMap.get(value);\n        if (!weakKey)\n            return false;\n        const __target__ = this.#baseMap.get(weakKey, strongKey);\n        if (!__target__)\n            return false;\n        const __returnValue__ = this.#baseMap.delete(weakKey, strongKey);\n        if (__returnValue__) {\n            this.#weakValueToInternalKeyMap.delete(__target__);\n            const remainingKeys = this.#baseMap.strongKeysFor(weakKey);\n            if (remainingKeys.size < 2) {\n                for (const otherStrongKey of remainingKeys) {\n                    const otherTarget = this.#baseMap.get(weakKey, otherStrongKey);\n                    this.#weakValueToInternalKeyMap.delete(otherTarget);\n                    this.#baseMap.delete(weakKey, otherStrongKey);\n                }\n            }\n        }\n        return __returnValue__;\n    }\n    /**\n     * Get a target value.\n     *\n     * @param value - The value.\n     * @param strongKey - The strongly held key.\n     * @returns The target value.\n     */\n    get(value, strongKey) {\n        const weakKey = this.#weakValueToInternalKeyMap.get(value);\n        return weakKey ? this.#baseMap.get(weakKey, strongKey) : undefined;\n    }\n    /**\n     * Determine if a target value exists.\n     *\n     * @param value - The value.\n     * @param strongKey - The strongly held key.\n     * @returns True if the target value exists.\n     */\n    has(value, strongKey) {\n        const weakKey = this.#weakValueToInternalKeyMap.get(value);\n        return weakKey ? this.#baseMap.has(weakKey, strongKey) : false;\n    }\n    /**\n     * Determine if a target value is an identity in this map.\n     *\n     * @param value - The value.\n     * @param strongKey - The strongly held key.\n     * @param allowNotDefined - If true, treat the absence of the value as an identity.\n     * @returns True if the target value exists.\n     * @public\n     */\n    hasIdentity(value, strongKey, allowNotDefined) {\n        const weakKey = this.#weakValueToInternalKeyMap.get(value);\n        if (!weakKey) {\n            return allowNotDefined;\n        }\n        return this.#baseMap.get(weakKey, strongKey) === value;\n    }\n    [Symbol.toStringTag] = \"OneToOneStrongMap\";\n}\nObject.freeze(OneToOneStrongMap);\nObject.freeze(OneToOneStrongMap.prototype);\n",
            "WeakStrongMap.js": "export default class WeakStrongMap {\n    #root = new WeakMap;\n    constructor(iterable) {\n        if (iterable) {\n            for (const [weakKey, strongKey, value] of iterable) {\n                this.set(weakKey, strongKey, value);\n            }\n        }\n    }\n    /**\n     * Delete an element from the collection by the given key sequence.\n     *\n     * @param weakKey - The weakly held key.\n     * @param strongKey - The strongly held key.\n     * @returns True if we found the value and deleted it.\n     */\n    delete(weakKey, strongKey) {\n        const innerMap = this.#root.get(weakKey);\n        if (!innerMap)\n            return false;\n        const rv = innerMap.delete(strongKey);\n        if (innerMap.size === 0) {\n            this.#root.delete(weakKey);\n        }\n        return rv;\n    }\n    /**\n     * Get a value for a key set.\n     *\n     * @param weakKey - The weakly held key.\n     * @param strongKey - The strongly held key.\n     * @returns The value.  Undefined if it isn't in the collection.\n     */\n    get(weakKey, strongKey) {\n        return this.#root.get(weakKey)?.get(strongKey);\n    }\n    /**\n     * Guarantee a value for a key set.\n     *\n     * @param weakKey - The weakly held key.\n     * @param strongKey - The strongly held key.\n     * @param defaultGetter - A function to provide a default value if necessary.\n     * @returns The value.\n     */\n    getDefault(weakKey, strongKey, defaultGetter) {\n        if (!this.has(weakKey, strongKey)) {\n            const result = defaultGetter();\n            this.set(weakKey, strongKey, result);\n            return result;\n        }\n        return this.get(weakKey, strongKey);\n    }\n    strongKeysFor(weakKey) {\n        const innerMap = this.#root.get(weakKey);\n        return new Set(innerMap?.keys() ?? []);\n    }\n    /**\n     * Report if the collection has a value for a key set.\n     *\n     * @param weakKey -The weakly held key.\n     * @param strongKey - The strongly held key.\n     * @returns True if the key set refers to a value in the collection.\n     */\n    has(weakKey, strongKey) {\n        return this.#root?.get(weakKey)?.has(strongKey) ?? false;\n    }\n    /**\n     * Set a value for a key set.\n     *\n     * @param weakKey - The weakly held key.\n     * @param strongKey - The strongly held key.\n     * @param value - The value.\n     */\n    set(weakKey, strongKey, value) {\n        if (!this.#root.has(weakKey)) {\n            this.#root.set(weakKey, new Map);\n        }\n        this.#root.get(weakKey).set(strongKey, value);\n        return this;\n    }\n    [Symbol.toStringTag] = \"WeakStrongMap\";\n}\nObject.freeze(WeakStrongMap);\nObject.freeze(WeakStrongMap.prototype);\n"
          }
        },
        "reference-spec": {
          "OneToOneStrongMap.js": "import \"es-search-references/guest\";\nimport OneToOneStrongMap from \"../fixtures/OneToOneStrongMap/OneToOneStrongMap.js\";\nclass DummyMembrane {\n    static #INTERNAL_KEY = Symbol(\"Internal object graph\");\n    #map = new OneToOneStrongMap;\n    addArray(firstKey, firstArray, secondKey, secondArray) {\n        if (!this.#map.has(firstArray, firstKey)) {\n            const internalArray = [];\n            for (let index = 0; index < firstArray.length; index++) {\n                internalArray.push({});\n            }\n            /* Now, here's where things might go wrong.  The internal key isn't supposed to be\n            something we hold objects for.  But the OneToOneStrongMap has no way of knowing\n            this...\n            */\n            this.#map.bindOneToOne(firstKey, firstArray, DummyMembrane.#INTERNAL_KEY, internalArray);\n        }\n        this.#map.bindOneToOne(firstKey, firstArray, secondKey, secondArray);\n    }\n}\n{\n    const membrane = new DummyMembrane;\n    const redArray = [{ isRedObject: true }];\n    const blueArray = [{ isBlueObject: true }];\n    const { proxy: redArrayProxy, revoke: redArrayRevoke } = Proxy.revocable(redArray, Reflect);\n    membrane.addArray(\"red\", redArrayProxy, \"blue\", blueArray);\n    const redOwner = [redArray];\n    const blueOwner = [blueArray];\n    const { proxy: redOwnerProxy, revoke: redOwnerRevoke } = Proxy.revocable(redOwner, Reflect);\n    membrane.addArray(\"red\", redOwnerProxy, \"blue\", blueOwner);\n    /* redArray should still be reachable:\n    - the OneToOneStrongMap bound the blue objects to red proxies.\n    - the red proxies pointed to the red objects.\n    */\n    searchReferences(\"proxied redArray via blueOwner\", redArray, [membrane, blueOwner], true);\n    redArrayRevoke();\n    redOwnerRevoke();\n    /* This time the answer should be no:\n    - we revoked the proxies, so the red objects aren't reachable that way.\n    */\n    searchReferences(\"revoked redArray via blueOwner\", redArray, [membrane, blueOwner], true);\n    /* but did we clean up the proxies? */\n    searchReferences(\"redArrayProxy via blueOwner\", redArrayProxy, [membrane, blueOwner], true);\n    searchReferences(\"redOwnerProxy via blueOwner\", redOwnerProxy, [membrane, blueOwner], true);\n}\n",
          "classes": {
            "classAccessors.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nconst vehicleToOwnerMap = new WeakMap;\nclass Vehicle {\n    constructor(owner) {\n        vehicleToOwnerMap.set(this, owner);\n    }\n    get owner() {\n        return vehicleToOwnerMap.get(this);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisCar = new Vehicle(Fred);\n// `hisCar.owner === Fred`\nsearchReferences(\"reaching a value via a getter\", Fred, [hisCar], true);\nclass Bicycle {\n    constructor(rider) {\n        vehicleToOwnerMap.set(this, rider);\n    }\n    set rider(newRider) {\n        vehicleToOwnerMap.set(this, newRider);\n    }\n}\nconst Wilma = new Person(\"Wilma\");\nconst herBike = new Bicycle(Wilma);\n// this should come back null:  there's no way to get a rider from herBike.\nsearchReferences(\"unreachable values with only a setter route\", Wilma, [herBike], true);\n",
            "classPrivateAccessors.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nconst vehicleToOwnerMap = new WeakMap;\nclass Vehicle {\n    constructor(owner) {\n        vehicleToOwnerMap.set(this, owner);\n        void (this.#owner);\n    }\n    get #owner() {\n        return vehicleToOwnerMap.get(this);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisBike = new Vehicle(Fred);\nsearchReferences(\"class private getter\", Fred, [hisBike], true);\nclass Bicycle {\n    constructor(rider) {\n        this.#rider = rider;\n    }\n    set #rider(newRider) {\n        vehicleToOwnerMap.set(this, newRider);\n    }\n}\nconst Wilma = new Person(\"Wilma\");\nconst herBike = new Bicycle(Wilma);\n// this should come back null:  there's no way to get a rider from herBike.\nsearchReferences(\"unreachable values with only a setter route\", Wilma, [herBike], true);\n// no need for subclass tests: private fields live with the instance directly\n",
            "classPrivateFields.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nclass Vehicle {\n    #owner;\n    constructor(owner) {\n        this.#owner = owner;\n        void (this.#owner);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisBike = new Vehicle(Fred);\nsearchReferences(\"class private fields\", Fred, [hisBike], true);\n// no need for subclass tests: private fields live with the instance directly\n",
            "classStaticAccessors.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nconst vehicleToOwnerMap = new Map;\nclass Vehicle {\n    static get owners() {\n        return vehicleToOwnerMap;\n    }\n    constructor(owner) {\n        vehicleToOwnerMap.set(this, owner);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisCar = new Vehicle(Fred);\nvoid (hisCar);\nsearchReferences(\"class static getters\", Fred, [Vehicle], true);\n",
            "classStaticFields.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nclass Vehicle {\n    static owners = [];\n    constructor(owner) {\n        Vehicle.owners.push(owner);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisCar = new Vehicle(Fred);\nsearchReferences(\"class static fields\", Fred, [hisCar], true);\n",
            "classStaticPrivateAccessors.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nconst vehicleToOwnerMap = new Map;\nclass Vehicle {\n    static get #owners() {\n        return vehicleToOwnerMap;\n    }\n    constructor(owner) {\n        Vehicle.#owners.set(this, owner);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisCar = new Vehicle(Fred);\nvoid (hisCar);\nsearchReferences(\"class static getters\", Fred, [Vehicle], true);\n",
            "classStaticPrivateFields.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nclass Vehicle {\n    static #owners = [];\n    constructor(owner) {\n        Vehicle.#owners.push(owner);\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisBike = new Vehicle(Fred);\nsearchReferences(\"class private static fields\", Fred, [hisBike], true);\n",
            "classesExtendingBuiltins.js": "import \"es-search-references/guest\";\nclass DefaultWeakMap extends WeakMap {\n    getDefault(key, builder) {\n        let value = this.get(key);\n        if (!value) {\n            value = builder();\n            this.set(key, value);\n        }\n        return value;\n    }\n}\nconst map = new DefaultWeakMap;\nconst target = {};\nmap.set(target, true);\n// this should come up empty:  I exclude edges to built-ins via the `[[Prototype]]` chain.\nsearchReferences(\"DefaultWeakMap extends WeakMap\", WeakMap, [map], true);\n",
            "classesExtendingOtherClasses.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nclass Vehicle {\n    owner;\n    constructor(owner) {\n        this.owner = owner;\n    }\n}\nclass Bicycle extends Vehicle {\n    driver;\n    constructor(owner, driver) {\n        super(owner);\n        this.driver = driver;\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst Betty = new Person(\"Betty\");\nconst hisBike = new Bicycle(Fred, Betty);\nsearchReferences(\"Bicycle extends Vehicle\", Vehicle, [hisBike], true);\n",
            "classesWithoutExtensions.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nclass Vehicle {\n    owner;\n    constructor(owner) {\n        this.owner = owner;\n    }\n}\nconst Fred = new Person(\"Fred\");\nconst hisBike = new Vehicle(Fred);\nsearchReferences(\"instance to class\", Vehicle, [hisBike], true);\n"
          },
          "collections": {
            "mapKeyIsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst value = { isValue: true };\nconst objectHoldingTarget = new Map([[target, value]]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"strongMapHoldsKeyStrongly\", target, heldValues, true);\n",
            "mapValueIsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst key = { isKey: true };\nconst objectHoldingTarget = new Map([[key, target]]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"strongMapHoldsValueStrongly\", target, heldValues, true);\n",
            "setHoldsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst objectHoldingTarget = new Set([target]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"setHoldsTargetStrongly\", target, heldValues, true);\n",
            "weakMapKeyIsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst objectHoldingTarget = new WeakMap([[target, true]]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"weakMapHoldsKeyStrongly\", target, heldValues, true);\nsearchReferences(\"weakMapHoldsKeyWeakly\", target, heldValues, false);\n",
            "weakMapValueIsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst key = { isKey: true };\nconst objectHoldingTarget = new WeakMap([[key, target]]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"weakMapHoldsValueStrongly\", target, heldValues, true);\nsearchReferences(\"weakMapHoldsValueWeakly\", target, heldValues, false);\nheldValues.push(key);\nsearchReferences(\"weakMapAndKeyJointlyHoldValue\", target, heldValues, true);\n",
            "weakSetHoldsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst objectHoldingTarget = new WeakSet([target]);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"weakSetHoldsTargetStrongly\", target, heldValues, true);\nsearchReferences(\"weakSetHoldsTargetWeakly\", target, heldValues, false);\n"
          },
          "functions": {
            "arrow.js": "import \"es-search-references/guest\";\nclass PropertyKeySorter {\n    #symbolMap = new Map;\n    /*\n    addSymbol(key: symbol) : void\n    {\n      if (!this.#symbolMap.has(key))\n        this.#symbolMap.set(key, this.#symbolMap.size + 1);\n    }\n  \n    sort(keys: propertyKey[]) : void\n    {\n      keys.forEach(key => {\n        if (typeof key === \"symbol\")\n          this.addSymbol(key);\n      });\n  \n      keys.sort(this.compare);\n    }\n    */\n    compare = (a, b) => {\n        const tA = typeof a, tB = typeof b;\n        if (tA === \"string\") {\n            if (tB === \"string\")\n                return tA.localeCompare(tB);\n            return -1;\n        }\n        if (tB === \"string\")\n            return +1;\n        const sA = this.#symbolMap.get(a), sB = this.#symbolMap.get(b);\n        return sA - sB;\n    };\n}\nconst sorter = new PropertyKeySorter;\nsearchReferences(\"this as part of an arrow function\", sorter, [sorter.compare], true);\n",
            "arrowReturnValue.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst returnTarget = () => target;\nsearchReferences(\"return target\", target, [returnTarget], true);\n",
            "asyncArrow.js": "import \"es-search-references/guest\";\nclass PropertyKeySorter {\n    #symbolMap = new Map;\n    compare = async (a, b) => {\n        await Promise.resolve();\n        const tA = typeof a, tB = typeof b;\n        if (tA === \"string\") {\n            if (tB === \"string\")\n                return tA.localeCompare(tB);\n            return -1;\n        }\n        if (tB === \"string\")\n            return +1;\n        const sA = this.#symbolMap.get(a), sB = this.#symbolMap.get(b);\n        return sA - sB;\n    };\n}\nconst sorter = new PropertyKeySorter;\nsearchReferences(\"this as part of an arrow function\", sorter, [sorter.compare], true);\n",
            "asyncClosures.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst miscellaneous = { isSomeOtherObject: true };\nfunction createShallowEnclosure(firstValue, secondValue) {\n    return async function () {\n        await Promise.resolve();\n        void (secondValue);\n        return firstValue;\n    };\n}\nconst oneLevelDeepEnclosure = createShallowEnclosure(miscellaneous, target);\nsearchReferences(\"targetNotDirectlyHeld\", target, [oneLevelDeepEnclosure], true);\nfunction createDeepEnclosure(firstValue, secondValue) {\n    return function () {\n        return async function () {\n            await Promise.resolve();\n            void (secondValue);\n            return firstValue;\n        };\n    };\n}\nconst outerEnclosure = createDeepEnclosure(miscellaneous, target);\nsearchReferences(\"outerEnclosure\", target, [outerEnclosure], true);\nconst innerEnclosure = outerEnclosure();\nsearchReferences(\"innerEnclosure\", target, [innerEnclosure], true);\n",
            "bound.js": "import \"es-search-references/guest\";\nclass Person {\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n}\nconst vehicleToOwnerMap = new WeakMap;\nclass Vehicle {\n    constructor(owner) {\n        vehicleToOwnerMap.set(this, owner);\n    }\n}\nfunction getOwner(vehicle) {\n    return this.get(vehicle);\n}\nconst Fred = new Person(\"Fred\");\nconst hisBike = new Vehicle(Fred);\nconst boundGetOwner = getOwner.bind(vehicleToOwnerMap, hisBike);\nsearchReferences(\"bound function to target\", Fred, [boundGetOwner], true);\n",
            "closures.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst miscellaneous = { isSomeOtherObject: true };\nfunction createShallowEnclosure(firstValue, secondValue) {\n    return function () {\n        void (secondValue);\n        return firstValue;\n    };\n}\nconst oneLevelDeepEnclosure = createShallowEnclosure(miscellaneous, target);\nsearchReferences(\"targetNotDirectlyHeld\", target, [oneLevelDeepEnclosure], true);\nfunction createDeepEnclosure(firstValue, secondValue) {\n    return function () {\n        return function () {\n            void (secondValue);\n            return firstValue;\n        };\n    };\n}\nconst outerEnclosure = createDeepEnclosure(miscellaneous, target);\nsearchReferences(\"outerEnclosure\", target, [outerEnclosure], true);\nconst innerEnclosure = outerEnclosure();\nsearchReferences(\"innerEnclosure\", target, [innerEnclosure], true);\n",
            "returnValue.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nfunction returnTarget() {\n    return target;\n}\nsearchReferences(\"return target\", target, [returnTarget], true);\n"
          },
          "iterators": {
            "array.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst firstValue = { isFirstValue: true };\nconst lastValue = { isLastValue: true };\nconst iterator = ([firstValue, target, lastValue]).values();\nsearchReferences(\"before visiting any values\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the first value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the target value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the last value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after completing the iterator\", target, [iterator], true);\n",
            "helpers.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst firstValue = { isFirstValue: true };\nconst lastValue = { isLastValue: true };\nlet iterator = ([firstValue, target, lastValue]).values();\n//@ts-expect-error this isn't supported in TypeScript's ES2024... ES2025 may have it.\niterator = iterator.filter((p) => p !== lastValue);\nsearchReferences(\"before visiting any values\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the first value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the target value\", target, [iterator], true);\n/* we're excluding the last value, so the next call will be { value: undefined, done: true }\nvoid(iterator.next());\nsearchReferences(\"after visiting the last value\", target, [iterator], true);\n*/\nvoid (iterator.next());\nsearchReferences(\"after completing the iterator\", target, [iterator], true);\n",
            "map.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst firstValue = { isFirstValue: true };\nconst lastValue = { isLastValue: true };\nconst iterator = new Map([\n    [0, firstValue],\n    [1, target,],\n    [2, lastValue]\n]).values();\nsearchReferences(\"before visiting any values\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the first value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the target value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the last value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after completing the iterator\", target, [iterator], true);\n",
            "regExpString.js": "export {};\n// nothing here yet, not sure we need this\n",
            "set.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst firstValue = { isFirstValue: true };\nconst lastValue = { isLastValue: true };\nconst iterator = new Set([firstValue, target, lastValue]).values();\nsearchReferences(\"before visiting any values\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the first value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the target value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after visiting the last value\", target, [iterator], true);\nvoid (iterator.next());\nsearchReferences(\"after completing the iterator\", target, [iterator], true);\n",
            "user-defined.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst firstValue = { isFirstValue: true };\nconst lastValue = { isLastValue: true };\nclass ObjectIterator {\n    #count = 0;\n    next(...[value]) {\n        void (value);\n        if (this.#count === 0) {\n            this.#count++;\n            return { value: firstValue, done: false };\n        }\n        if (this.#count === 1) {\n            this.#count++;\n            return { value: target, done: false };\n        }\n        if (this.#count === 2) {\n            this.#count++;\n            return { value: lastValue, done: true };\n        }\n        return { value: undefined, done: true };\n    }\n}\nconst iter = new ObjectIterator;\nsearchReferences(\"no explicit hold\", target, [iter], true);\n"
          },
          "module-imports": {
            "exportAddProperty.js": "import \"es-search-references/guest\";\nimport wrapObject from \"./exportWrapObject.js\";\nexport default function addProperty(value) {\n    return {\n        ...wrapObject(value),\n        addedProperty: { isAddedProperty: true },\n    };\n}\n",
            "exportWrapObject.js": "import \"es-search-references/guest\";\nexport default function wrapObject(value) {\n    return { value };\n}\n",
            "importWrapObject.js": "import \"es-search-references/guest\";\nimport addProperty from \"./exportAddProperty.js\";\nconst target = { isTarget: true };\nconst objectHoldingTarget = addProperty(target);\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"importWrapObject\", target, heldValues, true);\n"
          },
          "simple": {
            "asyncGenerators.js": "import \"es-search-references/guest\";\nclass IdObject {\n    id;\n    constructor(id) {\n        this.id = id;\n    }\n}\nconst target = new IdObject(\"target\");\nconst firstValue = new IdObject(\"firstValue\");\nconst lastValue = new IdObject(\"lastValue\");\nasync function* objectGenerator() {\n    yield await Promise.resolve(firstValue);\n    yield await Promise.resolve(target);\n    yield await Promise.resolve(lastValue);\n    return;\n}\nconst generator = objectGenerator();\nsearchReferences(\"generator holds target strongly\", target, [generator], true);\n",
            "finalizationRegistry.js": "import \"es-search-references/guest\";\nconst foundHeldValues = new Set;\nfunction callback(value) {\n    foundHeldValues.add(value);\n}\nconst registry = new FinalizationRegistry(callback);\nsearchReferences(\"callback\", callback, [registry], true);\nconst target = { isTarget: true };\nconst registryHeld = { isRegistryHeld: true };\nconst token = { isToken: true };\nregistry.register(target, registryHeld, token);\nsearchReferences(\"target before unregistration (strong)\", target, [registry], true);\nsearchReferences(\"target before unregistration (weak)\", target, [registry], false);\nsearchReferences(\"heldValue before unregistration (strong)\", registryHeld, [registry], true);\nsearchReferences(\"heldValue before unregistration (weak)\", registryHeld, [registry], false);\nsearchReferences(\"heldValue before unregistration (joint)\", registryHeld, [registry, target], true);\nsearchReferences(\"unregisterToken before unregistration (strong)\", token, [registry], true);\nsearchReferences(\"unregisterToken before unregistration (weak)\", token, [registry], false);\nsearchReferences(\"unregisterToken before unregistration (joint)\", token, [registry, target], false);\nregistry.unregister(token);\nsearchReferences(\"target after unregistration\", target, [registry], false);\nsearchReferences(\"heldValue after unregistration\", registryHeld, [registry], true);\nsearchReferences(\"unregisterToken after unregistration\", token, [registry], false);\n",
            "generators.js": "import \"es-search-references/guest\";\nclass IdObject {\n    id;\n    constructor(id) {\n        this.id = id;\n    }\n}\nconst target = new IdObject(\"target\");\nconst firstValue = new IdObject(\"firstValue\");\nconst lastValue = new IdObject(\"lastValue\");\nfunction* objectGenerator() {\n    yield firstValue;\n    yield target;\n    return lastValue;\n}\nconst generator = objectGenerator();\nsearchReferences(\"generator holds target strongly\", target, [generator], true);\n",
            "promises.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\n{\n    const { promise, resolve } = Promise.withResolvers();\n    resolve(target);\n    searchReferences(\"promise directly resolved to target\", target, [promise], true);\n}\n{\n    const { promise, reject } = Promise.withResolvers();\n    reject(target);\n    searchReferences(\"promise directly rejected to target\", target, [promise], true);\n    promise.catch(() => { void (null); });\n}\n//#region then, resolve()\n{\n    const { promise, resolve } = Promise.withResolvers();\n    const afterPromise = promise.then(() => target);\n    searchReferences(\"promise.then() to target, before resolve\", target, [promise], true);\n    searchReferences(\"promise.then() pending target, before resolve\", target, [afterPromise], true);\n    resolve();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.then() to target, after resolve\", target, [promise], true);\n    searchReferences(\"promise.then() resolved to target\", target, [afterPromise], true);\n}\n//#endregion then, resolve()\n//#region catch, resolve()\n{\n    const { promise, resolve } = Promise.withResolvers();\n    const afterPromise = promise.catch(() => target);\n    searchReferences(\"promise.catch() to target, before resolve\", target, [promise], true);\n    searchReferences(\"promise.catch() pending target, before resolve\", target, [afterPromise], true);\n    resolve();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.catch() to target, after resolve\", target, [promise], true);\n    searchReferences(\"promise.catch() resolved to target\", target, [afterPromise], true);\n}\n//#endregion catch, resolve()\n//#region finally, resolve()\n{\n    const { promise, resolve } = Promise.withResolvers();\n    promise.finally(() => { return target; });\n    searchReferences(\"promise.finally() to target, before resolve\", target, [promise], true);\n    resolve();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.finally() to target, after resolve\", target, [promise], true);\n}\n//#endregion finally, resolve()\n//#region then, reject()\n{\n    const { promise, reject } = Promise.withResolvers();\n    const afterPromise = promise.then(() => target);\n    afterPromise.catch(() => void (null));\n    // no test before reject, as this duplicates the .then()/resolve() case above to this point\n    reject();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.then() to target, after reject\", target, [promise], true);\n    searchReferences(\"promise.then() rejected to target\", target, [afterPromise], true);\n}\n//#endregion then, reject()\n//#region catch, reject()\n{\n    const { promise, reject } = Promise.withResolvers();\n    const afterPromise = promise.catch(() => target);\n    // no test before reject, as this duplicates the .catch()/resolve() case above to this point\n    reject();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.catch() to target, after reject\", target, [promise], true);\n    searchReferences(\"promise.catch() rejected to target\", target, [afterPromise], true);\n}\n//#region finally, reject()\n{\n    const { promise, reject } = Promise.withResolvers();\n    promise.finally(() => target).catch(() => void (null));\n    // no test before reject, as this duplicates the .finally()/resolve() case above to this point\n    reject();\n    // this runs the jobs through promise and afterPromise.\n    await Promise.resolve();\n    searchReferences(\"promise.finally() to target, after reject\", target, [promise], true);\n}\n//#endregion finally, reject()\n/*\n  Promise.all, Promise.race, etc. do not hold references to their passed-in\n  iterable's members.  Rather, each member holds a reference to the returned promise.\n\n  So looking up references on a Promise.all call is useless.\n*/\n",
            "proxies.js": "import \"es-search-references/guest\";\nconst NotImplementedProxyHandler = {\n    searchTarget: { searchTargetOf: \"ProxyHandler\" },\n    apply(target, thisArg, argArray) {\n        throw new Error(\"Method not implemented.\");\n    },\n    construct(target, argArray, newTarget) {\n        throw new Error(\"Method not implemented.\");\n    },\n    defineProperty(target, property, attributes) {\n        throw new Error(\"Method not implemented.\");\n    },\n    deleteProperty(target, p) {\n        throw new Error(\"Method not implemented.\");\n    },\n    get(target, p, receiver) {\n        throw new Error(\"Method not implemented.\");\n    },\n    getOwnPropertyDescriptor(target, p) {\n        throw new Error(\"Method not implemented.\");\n    },\n    getPrototypeOf(target) {\n        throw new Error(\"Method not implemented.\");\n    },\n    has(target, p) {\n        throw new Error(\"Method not implemented.\");\n    },\n    isExtensible(target) {\n        throw new Error(\"Method not implemented.\");\n    },\n    ownKeys(target) {\n        throw new Error(\"Method not implemented.\");\n    },\n    preventExtensions(target) {\n        throw new Error(\"Method not implemented.\");\n    },\n    set(target, p, newValue, receiver) {\n        throw new Error(\"Method not implemented.\");\n    },\n    setPrototypeOf(target, v) {\n        throw new Error(\"Method not implemented.\");\n    },\n};\nconst shadowTarget = {\n    searchTarget: {\n        searchTargetOf: \"shadowTarget\"\n    }\n};\nconst { proxy, revoke } = Proxy.revocable(shadowTarget, NotImplementedProxyHandler);\nsearchReferences(\"shadow target held before revocation\", shadowTarget, [proxy], true);\nsearchReferences(\"proxy handler held before revocation\", NotImplementedProxyHandler, [proxy], true);\nsearchReferences(\"proxy held before revocation\", proxy, [revoke], true);\nsearchReferences(\"revoke not held by proxy\", revoke, [proxy], false);\n// shadow targets shouldn't be searched\nsearchReferences(\"shadow search target\", shadowTarget.searchTarget, [proxy], false);\n// proxy handlers should be searched\nsearchReferences(\"proxy handler search target\", NotImplementedProxyHandler.searchTarget, [proxy], true);\nrevoke();\nsearchReferences(\"shadow target held by proxy after revocation\", shadowTarget, [proxy], false);\nsearchReferences(\"proxy handler held by proxy after revocation\", NotImplementedProxyHandler, [proxy], false);\nsearchReferences(\"proxy held after revocation\", proxy, [revoke], false);\n",
            "symbolKeyHoldsTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst symbolKey = Symbol(\"This is a symbol\");\nconst objectHoldingTarget = { [symbolKey]: target };\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"symbolKeyHoldsTarget\", target, heldValues, true);\n",
            "targetInHeldValuesArray.js": "import \"es-search-references/guest\";\nconst objectTarget = { isTarget: true };\nconst differentTargetName = objectTarget;\nconst isFirstValue = { isFirstValue: true };\nconst symbolTarget = Symbol(\"is symbol target\");\nconst heldValues = [\n    isFirstValue,\n    differentTargetName,\n    symbolTarget,\n];\nsearchReferences(\"target object in held values\", objectTarget, heldValues, true);\nsearchReferences(\"target symbol in held values\", symbolTarget, heldValues, true);\n",
            "targetIsElementOfHeldArray.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst arrayHoldingTarget = [target];\nconst isFirstValue = { isFirstValue: true };\nconst isLastValue = { isLastValue: true };\nconst heldValues = [\n    isFirstValue,\n    arrayHoldingTarget,\n    isLastValue,\n];\nsearchReferences(\"targetIsElementOfHeldArray\", target, heldValues, true);\n",
            "targetIsElementOfHeldObject.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst objectHoldingTarget = { target };\nconst isFirstValue = { isFirstValue: true };\nconst isLastValue = { isLastValue: true };\nconst heldValues = [\n    isFirstValue,\n    objectHoldingTarget,\n    isLastValue,\n];\nsearchReferences(\"targetIsElementOfHeldObject\", target, heldValues, true);\n",
            "targetIsSymbolKeyOfHeldObject.js": "import \"es-search-references/guest\";\nconst target = Symbol(\"is target\");\nconst isTailValue = { isTailValue: true };\nconst objectHoldingTarget = { [target]: isTailValue };\nconst heldValues = [\n    objectHoldingTarget,\n];\nsearchReferences(\"target is symbol key of held object\", target, heldValues, true);\n",
            "targetUnreachable.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst isFirstValue = { isFirstValue: true };\nconst isLastValue = { isLastValue: true };\nconst heldValues = [\n    isFirstValue,\n    isLastValue,\n];\nsearchReferences(\"targetUnreachable\", target, heldValues, true);\n",
            "weakRefToTarget.js": "import \"es-search-references/guest\";\nconst target = { isTarget: true };\nconst weakRef = new WeakRef(target);\nconst heldValues = [\n    weakRef,\n];\nsearchReferences(\"WeakRef to target does not hold strongly\", target, heldValues, true);\nsearchReferences(\"weakRef to target holds weakly\", target, heldValues, false);\n"
          }
        }
      }
    }
  }
};
export {
  ReferenceSpecRecord
}
